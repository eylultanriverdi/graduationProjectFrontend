{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Signal_1 = require(\"./Signal\");\n\nvar Geom = require(\"./Geometry\");\n\nvar RLDDLogic = function () {\n  function RLDDLogic(threshold, dragDelay) {\n    this.threshold = threshold;\n    this.dragDelay = dragDelay;\n    this.onDragBeginSignal = new Signal_1.default();\n    this.onDragHoverSignal = new Signal_1.default();\n    this.onDragMoveSignal = new Signal_1.default();\n    this.onDragEndSignal = new Signal_1.default();\n    this.lastHoveredId = -1;\n    this.itemBoxRects = new Map();\n  }\n\n  RLDDLogic.prototype.getThreshold = function () {\n    return this.threshold;\n  };\n\n  RLDDLogic.prototype.getDragDelay = function () {\n    return this.dragDelay;\n  };\n\n  RLDDLogic.prototype.setItemIdBoxRect = function (itemId, boxRect) {\n    this.itemBoxRects.set(itemId, boxRect);\n  };\n\n  RLDDLogic.prototype.setFloatingItemBoxRect = function (boxRect) {\n    this.floatingItemBoxRect = boxRect;\n  };\n\n  RLDDLogic.prototype.handleDragBegin = function (draggedId) {\n    var draggedItemRect = this.itemBoxRects.get(draggedId);\n\n    if (draggedItemRect) {\n      this.onDragBeginSignal.dispatch(draggedId, draggedItemRect.width, draggedItemRect.height);\n    }\n  };\n\n  RLDDLogic.prototype.handleDragMove = function (id, offset) {\n    this.onDragMoveSignal.dispatch(id, offset);\n    this.updateHoveredItem();\n  };\n\n  RLDDLogic.prototype.handleDragEnd = function () {\n    this.onDragEndSignal.dispatch();\n  };\n\n  RLDDLogic.prototype.arrangeItems = function (items, index0, index1) {\n    var newItems = items.slice();\n\n    if (index0 !== index1) {\n      var item0 = newItems[index0];\n      var item1 = newItems[index1];\n      var index2 = -1;\n\n      if (index1 > index0) {\n        newItems.splice(index0, 1);\n        index2 = newItems.indexOf(item1) + 1;\n        newItems.splice(index2, 0, item0);\n      } else if (index1 < index0) {\n        newItems.splice(index0, 1);\n        index2 = newItems.indexOf(item1) + 0;\n        newItems.splice(index2, 0, item0);\n      }\n    }\n\n    return newItems;\n  };\n\n  RLDDLogic.prototype.updateHoveredItem = function () {\n    var hoveredId = this.findHoveredItemId();\n\n    if (hoveredId >= 0 && hoveredId !== this.lastHoveredId) {\n      this.lastHoveredId = hoveredId;\n      this.onDragHoverSignal.dispatch(hoveredId);\n    }\n  };\n\n  RLDDLogic.prototype.findHoveredItemId = function () {\n    if (Geom.isRectValid(this.floatingItemBoxRect)) {\n      var areas = this.calculateOverlappingAreas().sort(function (a, b) {\n        return b.area - a.area;\n      });\n\n      if (areas.length > 0 && areas[0].area > 0) {\n        return areas[0].id;\n      }\n    }\n\n    return -1;\n  };\n\n  RLDDLogic.prototype.calculateOverlappingAreas = function () {\n    var _this = this;\n\n    var areas = new Array();\n    this.itemBoxRects.forEach(function (rect, itemId) {\n      var area = Geom.getAreaOfIntersection(rect, _this.floatingItemBoxRect) / Geom.getRectArea(rect);\n      areas.push({\n        id: itemId,\n        area: area\n      });\n    });\n    return areas;\n  };\n\n  return RLDDLogic;\n}();\n\nexports.default = RLDDLogic;","map":{"version":3,"sources":["../src/RLDDLogic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Signal_1 = require(\"./Signal\");\nvar Geom = require(\"./Geometry\");\nvar RLDDLogic = (function () {\n    function RLDDLogic(threshold, dragDelay) {\n        this.threshold = threshold;\n        this.dragDelay = dragDelay;\n        this.onDragBeginSignal = new Signal_1.default();\n        this.onDragHoverSignal = new Signal_1.default();\n        this.onDragMoveSignal = new Signal_1.default();\n        this.onDragEndSignal = new Signal_1.default();\n        this.lastHoveredId = -1;\n        this.itemBoxRects = new Map();\n    }\n    RLDDLogic.prototype.getThreshold = function () {\n        return this.threshold;\n    };\n    RLDDLogic.prototype.getDragDelay = function () {\n        return this.dragDelay;\n    };\n    RLDDLogic.prototype.setItemIdBoxRect = function (itemId, boxRect) {\n        this.itemBoxRects.set(itemId, boxRect);\n    };\n    RLDDLogic.prototype.setFloatingItemBoxRect = function (boxRect) {\n        this.floatingItemBoxRect = boxRect;\n    };\n    RLDDLogic.prototype.handleDragBegin = function (draggedId) {\n        var draggedItemRect = this.itemBoxRects.get(draggedId);\n        if (draggedItemRect) {\n            this.onDragBeginSignal.dispatch(draggedId, draggedItemRect.width, draggedItemRect.height);\n        }\n    };\n    RLDDLogic.prototype.handleDragMove = function (id, offset) {\n        this.onDragMoveSignal.dispatch(id, offset);\n        this.updateHoveredItem();\n    };\n    RLDDLogic.prototype.handleDragEnd = function () {\n        this.onDragEndSignal.dispatch();\n    };\n    RLDDLogic.prototype.arrangeItems = function (items, index0, index1) {\n        var newItems = items.slice();\n        if (index0 !== index1) {\n            var item0 = newItems[index0];\n            var item1 = newItems[index1];\n            var index2 = -1;\n            if (index1 > index0) {\n                newItems.splice(index0, 1);\n                index2 = newItems.indexOf(item1) + 1;\n                newItems.splice(index2, 0, item0);\n            }\n            else if (index1 < index0) {\n                newItems.splice(index0, 1);\n                index2 = newItems.indexOf(item1) + 0;\n                newItems.splice(index2, 0, item0);\n            }\n        }\n        return newItems;\n    };\n    RLDDLogic.prototype.updateHoveredItem = function () {\n        var hoveredId = this.findHoveredItemId();\n        if (hoveredId >= 0 && hoveredId !== this.lastHoveredId) {\n            this.lastHoveredId = hoveredId;\n            this.onDragHoverSignal.dispatch(hoveredId);\n        }\n    };\n    RLDDLogic.prototype.findHoveredItemId = function () {\n        if (Geom.isRectValid(this.floatingItemBoxRect)) {\n            var areas = this.calculateOverlappingAreas().sort(function (a, b) { return b.area - a.area; });\n            if (areas.length > 0 && areas[0].area > 0) {\n                return areas[0].id;\n            }\n        }\n        return -1;\n    };\n    RLDDLogic.prototype.calculateOverlappingAreas = function () {\n        var _this = this;\n        var areas = new Array();\n        this.itemBoxRects.forEach(function (rect, itemId) {\n            var area = Geom.getAreaOfIntersection(rect, _this.floatingItemBoxRect) / Geom.getRectArea(rect);\n            areas.push({ id: itemId, area: area });\n        });\n        return areas;\n    };\n    return RLDDLogic;\n}());\nexports.default = RLDDLogic;\n//# sourceMappingURL=RLDDLogic.js.map"]},"metadata":{},"sourceType":"script"}